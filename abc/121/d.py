# -*- coding:utf-8 -*-

def solve2():
    """解説PDF
    任意の偶数nについて n ^ (n+1) = 1

    この性質は、最下位ビットのみが異なることからわかる。

    たとえば、
    F(0, 6) = 0^1^2^3^4^5^6
            = (0^1)^(2^3)^(4^5)^6
            = 1^1^1^6
    のように計算できる。

    また、排他的論理和の性質として、

    a ^ b = c
    a = c ^ b

    が成り立つので、（両辺に ^b するイメージ。b^b=0 である）

    F(0, B) = F(0, A-1) ^ F(A, B)
    F(A, B) = F(0, A-1) ^ F(0, B)

    が成り立つ。
    """
    A, B = list(map(int, input().split()))

    def calc(a):
        """ F(0, a)を返す。計算量O(1) """
        if a == 0:
            return 0
        elif a == 1:
            return 1

        # aが2以上の時 
        if a%2 == 0:
            # aが偶数のとき
            # F(0, a) = 1^1^...^1^a
            # 1の数は a/2 個
            if (a/2)%2 == 0:
                _ans = a
            else:
                _ans = 1^a
        else:
            # aが奇数の時
            # F(0, a) = 1^1^...^1^1
            # 1の数は (a+1)/2 個
            if ((a+1)/2)%2 == 0:
                _ans = 0
            else:
                _ans = 1
        
        return _ans
    
    # F(A, B) = F(0, A-1) ^ F(0, B)
    ans = calc(A-1) ^ calc(B)
    print(ans)


def solve():
    A, B = list(map(int, input().split()))

    """解説
    考え方としては、累積和みたいなかんじ
    「4~8までのxor」は、「0~8までのxor」 から 「0~3までのxor」 を引くかんじ

    A xor B = C のとき、
    A xor C = B であることに着目する

    各桁の1の数を数えれば求まる

    ・1~8のxor
    0000 | 0
    0001 | 1
    0010 | 2
    0011 | 3
    0100 | 4
    0101 | 5
    0110 | 6
    0111 | 7
    1000 | 8
    ----
    1001

    ・各桁の01の周期に着目する
    ・0桁目の周期は2
    ・1桁目の周期は4
    ・2桁目の周期は8
    ・3桁目の周期は16
    """

    def calc(a):
        """ F(0, a)を返す。 計算量O(log(B))? """
        # 10**3 <= 2**10 は
        # 1000  <= 1024 なので
        # 10**12 <= 2**40 (2進数で40桁くらい)
        if a <= 0: return 0

        ans = 0
        for i in range(0, 50):
            # i桁目の周期Tを調べる
            # 0桁目 -> 周期T=2
            # 1桁目 -> 周期T=4
            # 2桁目 -> 周期T=8
            T = 1 << (i+1)

            # 各桁の1の個数は
            # cnt = (ループした回数) * (1が出てくる回数)
            cnt = ((a+1)//T) * (T/2)
            # cnt += あまった1の数を足す
            cnt += max(0, ((a+1)%T) - (T/2))

            # その桁の1の数が奇数だったら足し算する
            if cnt%2 == 1:
                ans += 1 << i
        
        return ans

    ans = calc(B) ^ calc(A-1)
    print(ans)

if __name__ == "__main__":
    solve2()
