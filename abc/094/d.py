# -*- coding:utf-8 -*-
from math import factorial
import bisect


def solve():
    N = int(input())
    As = list(map(int, input().split()))

    # ai > aj
    # C(ai, aj) とするとき、aiは大きければ大きいほどよいので、Asの最大値でよい
    # 問題はajをどう決めるか。
    """
    C(n,r) を毎回計算するのは計算が重い。なので計算させずに済む方法を考える。
    C(n,r) = n! / r!(n-r)! である。今、nはAsの最大値と決まっているので、定数とみなして良い。
    よって、C(n,r)が大きいとは、分子の r!(n-r)!ができるだけ小さいものである。
    r!(n-r)!を全探索で計算するのも処理が重いのでしたくない。
    ところで、n=10のとき、r!(n-r)!を、r = 1 ~ 10まで手書きで書いてみるとわかるが、

    1) 1* 9*8*7*6*5*4*3*2*1
    2) 1*2* 8*7*6*5*4*3*2*1
    3) 1*2*3* 7*6*5*4*3*2*1
    4) 1*2*3*4* 6*5*4*3*2*1
    5) 1*2*3*4*5* 5*4*3*2*1  <-これが一番小さい
    6) 1*2*3*4*5*6* 4*3*2*1  <-これは4)と同じ

    r = n//2のときが一番小さくなるっぽいことがわかる。

    そのようなrを、Asの中から探せば良い。これは二分探索で高速に探せる。

    解説PDFを読むと、パスカルの三角形というのがあるらしく、上記の考察はこれで置き換えることができるらしい
    """

    As.sort()
    n = As[-1]
    i = bisect.bisect_left(As[:-1], n//2)
    if i == 0:
        r = As[0]
    elif i == N-1:
        r = As[N-2]
    else:
        if abs(As[i-1] - n//2) < abs(As[i] - n//2):
            r = As[i-1]
        else:
            r = As[i]

    print(n, r)


if __name__ == "__main__":
    solve()
