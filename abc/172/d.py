# -*- coding:utf-8 -*-

def solve():
    # O(NlogN)解放
    #
    # f(1)~f(N)までの総和を求めるということは、
    # 1の倍数の数
    # 2の倍数の数
    # 3の倍数の数...
    # を1からNまで計算して足していけばよい。
    #
    # 配列 anss[i] := iの倍数の個数
    # に対して、
    # i=1からNまで順に足して行けば良い。
    N = int(input())

    anss = [0]*(N+1)

    for i in range(1, N+1):
        j = 1
        while i*j <= N:
            anss[i*j] += 1
            j += 1

    ans = 0
    for i, a in enumerate(anss[1:]):
        ans += (i+1)*a
    print(ans)


def solve2():
    # O(N)の解法。
    #
    # f(1)~f(N)までの総和を求めるということは、
    # 1の倍数の数
    # 2の倍数の数
    # 3の倍数の数...
    # を1からNまで計算して足していけばよい。
    #
    # 1の倍数は    1,2,3,4,5,...
    # 2の倍数は 2*(1,2,3,4,5,...)
    # 3の倍数は 3*(1,2,3,4,5,...)
    # よって、Nまでの1の倍数の個数をg(N)とすると、
    # Nまでの2の倍数の個数は、g(N//2)
    # Nまでの3の倍数の個数は、g(N//3)
    #
    # これを利用すると、kの倍数の個数の計算はO(1)でできるので、
    # 全体の計算量はO(N)
    N = int(input())

    i = 1
    ans = 0
    while N//i != 0:
        n = N//i
        ans += i*((n*(n+1))//2)
        i += 1
    print(ans)


if __name__ == "__main__":
    solve2()
