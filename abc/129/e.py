# -*- coding:utf-8 -*-
"""解説
a+b = a^b とは、aとbを2進数にしたとき、1が互いに重なるbit桁がないこと（0は重なってもよい）。
言い換えると、a&b = 0

L < 2**100001
とはつまり、
Lを2進数で表したとき、最大のbit桁が100000

bit桁 | 100000 99999 99998 ... 3 2 1 0
a     |      1     0     1 ... 1 0 1 0
b     |      0     1     0 ... 0 1 0 1

のような、aとbのパターンの総数を求めればよい

どうやってパターンを数え上げればよいかわからなかったが、桁DPというのを使えば解けるらしい。

・桁DPの記事
https://torus711.hatenablog.com/entry/20150423/1429794075

ということでこの考察を元に桁DPを考える。

dp[i][j] := i桁目までみたときのパターンの場合の数
ただし、Lのi桁目の数字をDとするとき、
・過去にDより小さい値をいれたことがない: j=0
   - このとき、まだL以下の数字になることは確定していない
・過去にDより小さい値をいれたことがある: j=1
   - このとき、L以下の数字になることが確定している

aのi桁目の数字をDa、bのi桁目の数字をDbとする。

・i桁目が0になるとき、DaとDbのありえる組み合わせは、(Da, Db) = (0, 0)のみ。
・i桁目が1になるとき、DaとDbのありえる組み合わせは、(Da, Db) = (1, 0), (0, 1)

過去にDより小さい値を入れたことがある場合(j=1)、DaとDbの組み合わせは好きにしてもL以下になる。

過去にDより小さい値を入れたことがない場合(j=0)、DaとDbの組み合わせは、Dと一致するように選ばなければL以下にならない。

・例
L=101のとき、

a+b = ??? --- 0?? --- 00?
           |       |
           |       +- 01?
           |
           +- 1?? --- 10?
                   |
                   +- 11? この時点でLより大きいので、以降は調べなくてもよい(j=0) 
"""

def solve():
    L = input()
    MOD = 10**9+7
    n = len(L)

    # dp[i][j] := i桁目までみたときのパターンの場合の数
    # ただし、Lのi桁目の数字をDとするとき、
    # ・過去にDより小さい値をいれたことがない: j=0
    #    - このとき、まだL以下の数字になることは確定していない
    # ・過去にDより小さい値をいれたことがある: j=1
    #    - このとき、L以下の数字になることが確定しているので、好きな数字をいれてよい。
    dp = [[0 for j in range(2)] for i in range(n+1)]
    # L = 101 とするとき、一番左を0桁目とする。
    dp[0][0] = 2
    dp[0][1] = 0

    for i, D = in enumerate(L):
        if D == "1":
            dp[i+1][0] = dp[i][0]*2%MOD  # (1, 0), (0, 1)
            dp[i+1][1] = (dp[i][0] + dp[i][1]*3)%MOD
        else:
            dp[i+1][0] = dp[i][0]
            dp[1+1][1] = dp[i][1]

    










if __name__ == "__main__":
    solve()
