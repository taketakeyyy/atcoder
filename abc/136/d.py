# -*- coding:utf-8 -*-
"""考察
R R R L という例を考える

・i=0の人は最終的にどこにいるのか？
## 初期状態
i: 0 1 2 3
-----------
S: R R R L
   .

## 3回の操作のあと
i: 0 1 2 3
-----------
S: R R R L
         .

## 4回の操作のあと
i: 0 1 2 3
-----------
S: R R R L
       .

という風に、あとは奇数回の操作後はi=3のLに、偶数回の操作後はi=2のRにいることになる


・i=1の人は最終的にどこにいるのか？
## 初期状態
i: 0 1 2 3
-----------
S: R R R L
     .

## 2回の操作のあと
i: 0 1 2 3
-----------
S: R R R L
         .

## 3回の操作のあと
i: 0 1 2 3
-----------
S: R R R L
       .

という風に、あとは偶数回の操作の後はi=3のLに、奇数回の操作の後はi=2のRにいることになる。

以上の考察から、初期位置から移動を始めたあと、折返し地点までの距離によって、偶数回後と奇数回後で位置が収束されることがわかる。

そして操作は10^100回行われるので、偶数回のみ考えれば良い。

ここで初期位置をstart, 折返し地点のマスをendとする。

初期位置がstart=0の人の例で言うと、折返し地点end=3までの距離abc(start-end)=3が奇数の場合、この人は最終的にend-1(=2)にいることになる。

初期位置がstart=1の人の例で言うと、折返し地点end=3までの距離abc(start-end)=2が偶数の場合、この人は最終的にend(=3)にいることになる。

ということが言えそうである。

なので、あとはシミュレーションで答えを求めればよい。このシミュレーションはO(N)でできそうである

ここまで気づいたら、あとはどうシミュレーションを実装するかという話なのですが、

RグループとLグループに分けられそうだと思いつく。

たとえば

R R R L R L R L L L R R L という文字列を考えた場合、

 R R R  L  R  L  R  L L L  R R  L
|_____||_||_||_||_||_____||___||_|
   3    1  1  1  1    3     2   1

というふうに各グループの人数を数えることで、シミュレーションを簡単に実装できそうである。

つまり、一番左のRグループ(3人)に着目すると、

* グループの人数を cnt
* 折返し地点であるLまでの距離が偶数の人数を even_num
* 折返し地点であるLまでの距離が奇数の人数を odd_num

とそれぞれすると、

cnt = 3
even_num = cnt//2
odd_num = cnt - even_num

で求められるので、even_num は最終的に折返し地点に収束し、 odd_num は最終的に折返し地点の1つ左側に収束することがわかります。


一番右のLグループに着目すると、同様の考察で、
cnt, even_num, odd_num を求めて、even_numは最終的に折返し地点に収束し、odd_numは最終的に折返し地点の1つ右側に収束することがわかります。

"""
def solve():
    S = input()
    N = len(S)

    ans = [0]*N  # 最終的に出力する答え（10**100操作後に、人がいる人数）
    # Rグループについて考える
    cnt = 0  # 現在のRグループの人数
    for i, moji in enumerate(S):
        if moji == "R":
            cnt += 1
            continue
        else:
            even_num = cnt//2  # 距離が偶数の人の数
            ans[i] += even_num # 距離が偶数の人は、ans[i]に収束する
            odd_num = cnt - even_num  # 距離が奇数の人の数
            ans[i-1] += odd_num       # 距離が奇数の人は、ans[i-1]に収束する
            cnt = 0

    # Lグループについて考える
    cnt = 0  # Lグループの人数
    for i in range(N-1, -1, -1):
        if S[i] == "L":
            cnt += 1
            continue
        else:
            even_num = cnt//2
            ans[i] += even_num
            odd_num = cnt - even_num
            ans[i+1] += odd_num
            cnt = 0

    print(*ans)


if __name__ == "__main__":
    solve()
